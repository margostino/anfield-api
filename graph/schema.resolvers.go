package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.43

import (
	"context"
	"fmt"
	"sort"
	"strings"

	"github.com/margostino/anfield-api/db"
	"github.com/margostino/anfield-api/graph/model"
)

// Teams is the resolver for the teams field.
func (r *queryResolver) Teams(ctx context.Context) ([]*model.Team, error) {
	var response []*model.Team
	for _, team := range db.Data.Teams {
		response = append(response, toTeamGraph(team))
	}
	return response, nil
}

// Players is the resolver for the players field.
func (r *queryResolver) Players(ctx context.Context, teamShortName *string) ([]*model.Player, error) {
	var response []*model.Player
	for _, player := range db.Data.Players {
		if teamShortName != nil {
			if !strings.EqualFold(player.TeamShortName, *teamShortName) {
				continue
			}
		}
		response = append(response, toPlayerGraph(player))
	}
	return response, nil
}

// Events is the resolver for the events field.
func (r *queryResolver) Events(ctx context.Context, teamShortName *string) ([]*model.Event, error) {
	var response []*model.Event
	for _, event := range db.Data.Events {
		if teamShortName != nil {
			var fixtures []*db.Fixture
			for _, fixture := range event.Fixtures {
				if strings.EqualFold(*fixture.TeamAShortName, *teamShortName) || strings.EqualFold(*fixture.TeamHShortName, *teamShortName) {
					fixtures = append(fixtures, fixture)
				}
			}
			if len(fixtures) == 0 {
				continue
			}
			event.Fixtures = fixtures
		}
		response = append(response, toEventGraph(*event))
	}
	sort.Slice(response, func(i, j int) bool { return response[i].ID < response[j].ID })
	return response, nil
}

// Team is the resolver for the team field.
func (r *queryResolver) Team(ctx context.Context, shortName string) (*model.Team, error) {
	var key = strings.ToLower(shortName)
	var data = db.Data.Teams[key]
	var response = toTeamGraph(data)
	return response, nil
}

// Player is the resolver for the player field.
func (r *queryResolver) Player(ctx context.Context, webName string) (*model.Player, error) {
	key := strings.ToLower(webName)
	var data = db.Data.Players[key]
	var response = toPlayerGraph(data)
	return response, nil
}

// Event is the resolver for the event field.
func (r *queryResolver) Event(ctx context.Context, id int, teamShortName *string) (*model.Event, error) {
	var data = *db.Data.Events[id]

	if teamShortName != nil {
		var fixtures []*db.Fixture
		for _, fixture := range data.Fixtures {
			if strings.EqualFold(*fixture.TeamAShortName, *teamShortName) || strings.EqualFold(*fixture.TeamHShortName, *teamShortName) {
				fixtures = append(fixtures, fixture)
			}
		}
		if len(fixtures) > 0 {
			data.Fixtures = fixtures
		}
	}

	var response = toEventGraph(data)

	return response, nil
}

// H2h is the resolver for the h2h field.
func (r *queryResolver) H2h(ctx context.Context, teamAShortName string, teamHShortName string) (*model.H2h, error) {
	var teamAKey = strings.ToLower(teamAShortName)
	var teamHKey = strings.ToLower(teamHShortName)
	var teamAData = db.Data.Teams[teamAKey]
	var teamHData = db.Data.Teams[teamHKey]
	h2h := toH2HGraph(teamAData, teamHData)
	return h2h, nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func (r *queryResolver) Fixture(ctx context.Context, id int) (*model.Fixture, error) {
	panic(fmt.Errorf("not implemented: Fixture - fixture"))
}
func (r *queryResolver) Fixtures(ctx context.Context) ([]*model.Fixture, error) {
	panic(fmt.Errorf("not implemented: Fixtures - fixtures"))
}
